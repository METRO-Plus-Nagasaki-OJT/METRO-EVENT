{% load static %}
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="{% static 'css/app.css' %}?{% now 'U' %}">
    <script src="{% static 'js/mediapipe.js' %}"></script>
    <script defer src="{% static 'js/app.js' %}?{% now 'U' %}"></script>
    <style>
        @keyframes example {
            0% {
                top: 5%;
            }

            50% {
                top: 80%;
            }

            100% {
                top: 5%;
            }
        }

        .x {
            animation: example 3s linear infinite;
            position: absolute;
            left: 4%;
            right: 4%;
            border-bottom: 0;
            height: 150px;
            border-width: 7px;
            border-color: #ffffff transparent transparent transparent;
            border-radius: 50%/100px 100px 0 0;

        }

        .y {
            box-shadow: 18px -25px 50px 35px rgb(14 159 110);
        }
    </style>
</head>

<body>
    <div class="relative min-h-screen overflow-hidden">
        <video id="webcam" autoplay
            class="absolute-full object-cover scale-x-[-1]">
        </video>
        <canvas id="crop-face-canvas" hidden></canvas>
        <canvas id="canvas" class="absolute-full  object-cover "
            style=" visibility: hidden;"></canvas>
        <div class="transition-[0.05s] z-[10]  absolute hidden" id="face-box">
            <div class="w-full h-full relative bg-opacity-40 p-5">
                <div
                    class="absolute top-8 left-8 right-8 bottom-8 bg-white bg-opacity-30 rounded-3xl">
                </div>
                <div class="border x overflow-hidden">
                    <div class="y"></div>
                </div>
                <div
                    class="size-20 absolute border-t-8 border-l-8 left-0  top-0 rounded-ss-[50%]">
                </div>
                <div
                    class="size-20 absolute border-t-8 border-r-8 right-0 top-0 rounded-se-[50%] ">
                </div>
                <div
                    class="size-20 absolute border-l-8 border-b-8 left-0 bottom-0  rounded-bl-[50%]">
                </div>
                <div
                    class="size-20 absolute border-r-8 border-b-8 right-0 bottom-0 rounded-br-[50%]">
                </div>
            </div>
        </div>
        <div class="bg-red-700 absolute-full z-[100] bg-opacity-50  flex justify-center items-center"
            x-transition.duration.500ms x-data x-cloak
            x-show="$store.reception.messageStatus">
            <div class="min-w-[500px] max-w-[1200px] text-white text-center">
                <h2 class="text-3xl underline">メッセージがあります</h2>
                <p class=" text-[4rem]  mt-10" x-text="$store.reception.message"
                    x-transition:enter.duration.500ms
                    x-transition:leave.duration.400ms>
                </p>
            </div>
        </div>
        <div class="absolute top-5 left-5 right-5 bottom-5">
            <div
                class="w-full h-full flex flex-col justify-between p-5 relative ">
                <div
                    class="absolute border border-white w-full h-full top-0 right-0 border-t-0 border-b-0">
                </div>
                <div
                    class="top-0 left-0 right-0 absolute w-full flex justify-center ">
                    <div
                        class="border border-white border-r-0 border-b-0 border-l-0 w-9">
                    </div>
                    <div class="leading-[0px] px-3 text-white text-xl" x-data
                        x-text="$store.reception.time">0000-00-00
                        00:00:00
                    </div>
                    <div
                        class="border border-white border-r-0 border-b-0 border-l-0 flex-1">
                    </div>
                </div>
                <div
                    class="bottom-0 left-0 right-0 absolute w-full flex justify-center ">
                    <div
                        class="border border-white border-r-0 border-b-0 border-l-0 w-[90%]">
                    </div>
                    <div class="leading-[0px] px-3 text-white text-xl">P Hub
                    </div>
                    <div
                        class="border border-white border-r-0 border-b-0 border-l-0 flex-1">
                    </div>
                </div>
                <div class="flex justify-between">
                    <button id="mode-button" style="visibility: hidden;"
                        class="bg-teal-500 font-semibold z-50 px-[4%] py-[1%] text-[2rem]  text-center text-white rounded-[40px] border-[5px] border-white">
                        Mode : <span
                            x-text="$store.reception.in ? '入館': '退館'"></span>
                    </button>
                    <button @click="$store.reception.in = !$store.reception.in"
                        x-data
                        x-bind:class="$store.reception.in ? 'bg-teal-500' : 'bg-yellow-300'"
                        class="bg-teal-500 font-semibold  z-50 px-[4%] py-[1%] text-[2rem]  text-center text-white rounded-[40px] border-[5px] border-white">
                        Mode : <span class="font-semibold"
                            x-text="$store.reception.in ? '入館': '退館'"></span>
                    </button>
                </div>
                <div class="flex justify-between items-start px-3">
                    <div>
                        <div x-data x-show="$store.reception.verify"
                            x-transition:enter.duration.500ms
                            class="py-5 px-20 space-y-5 text-white rounded-lg bg-opacity-[0.4] bg-[#262323] flex flex-col justify-between items-center">
                            <div
                                class=" bg-lime-500 rounded-full flex justify-center items-center">
                                <svg xmlns="http://www.w3.org/2000/svg"
                                    viewBox="0 0 24 24"
                                    class=" size-40 fill-white">
                                    <path fill-rule="evenodd"
                                        d="M19.916 4.626a.75.75 0 0 1 .208 1.04l-9 13.5a.75.75 0 0 1-1.154.114l-6-6a.75.75 0 0 1 1.06-1.06l5.353 5.353 8.493-12.74a.75.75 0 0 1 1.04-.207Z"
                                        clip-rule="evenodd" />
                                </svg>
                            </div>
                            <div class="text-3xl font-semibold text-center">
                                ワインヤンリン
                                <br>
                                1年○○○○療法
                            </div>
                        </div>
                        <!-- <div class="bg-red-700 bg-opacity-45 max-w-[350px] text-white mt-5 p-2 rounded-lg">
                            問わ森自ハミテ散済はびで研供ソロ画感ツラ了遣
                        </div> -->
                    </div>
                    <div class="space-y-1" x-data>
                        <div x-show="$store.reception.faceRecognizationFailAlert"
                            x-transition:enter.duration.500ms>
                            <div
                                class="py-5 px-20 space-y-5 text-white rounded-lg bg-opacity-[0.4] bg-[#262323] flex flex-col justify-between items-center">
                                <div
                                    class=" bg-red-500 rounded-full flex justify-center items-center">
                                    <svg xmlns="http://www.w3.org/2000/svg"
                                        viewBox="0 0 24 24" fill="currentColor"
                                        class="fill-white size-40">
                                        <path fill-rule="evenodd"
                                            d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25Zm-1.72 6.97a.75.75 0 1 0-1.06 1.06L10.94 12l-1.72 1.72a.75.75 0 1 0 1.06 1.06L12 13.06l1.72 1.72a.75.75 0 1 0 1.06-1.06L13.06 12l1.72-1.72a.75.75 0 1 0-1.06-1.06L12 10.94l-1.72-1.72Z"
                                            clip-rule="evenodd" />
                                    </svg>
                                </div>
                                <div class="text-3xl font-semibold text-center">
                                    顔認識に
                                    <br>
                                    失敗しました.
                                </div>
                            </div>
                        </div>
                        <div x-transition:enter.duration.500ms
                            x-show="$store.reception.currentState === $store.reception.state().QR_DECETION"
                            class="px-20 py-5 space-y-3 relative  text-white items-center bg-opacity-[0.4] bg-[#262323] rounded-lg">
                            <div class="flex justify-center ">
                                <div class="bg-green-500 rounded-lg">
                                    <svg xmlns="http://www.w3.org/2000/svg"
                                        fill="none" viewBox="0 0 24 24"
                                        stroke-width="1.5" stroke="currentColor"
                                        class="size-40 text-white">
                                        <path stroke-linecap="round"
                                            stroke-linejoin="round"
                                            d="M3.75 4.875c0-.621.504-1.125 1.125-1.125h4.5c.621 0 1.125.504 1.125 1.125v4.5c0 .621-.504 1.125-1.125 1.125h-4.5A1.125 1.125 0 0 1 3.75 9.375v-4.5ZM3.75 14.625c0-.621.504-1.125 1.125-1.125h4.5c.621 0 1.125.504 1.125 1.125v4.5c0 .621-.504 1.125-1.125 1.125h-4.5a1.125 1.125 0 0 1-1.125-1.125v-4.5ZM13.5 4.875c0-.621.504-1.125 1.125-1.125h4.5c.621 0 1.125.504 1.125 1.125v4.5c0 .621-.504 1.125-1.125 1.125h-4.5A1.125 1.125 0 0 1 13.5 9.375v-4.5Z" />
                                        <path stroke-linecap="round"
                                            stroke-linejoin="round"
                                            d="M6.75 6.75h.75v.75h-.75v-.75ZM6.75 16.5h.75v.75h-.75v-.75ZM16.5 6.75h.75v.75h-.75v-.75ZM13.5 13.5h.75v.75h-.75v-.75ZM13.5 19.5h.75v.75h-.75v-.75ZM19.5 13.5h.75v.75h-.75v-.75ZM19.5 19.5h.75v.75h-.75v-.75ZM16.5 16.5h.75v.75h-.75v-.75Z" />
                                    </svg>
                                </div>
                            </div>
                            <div class="text-center font-semibold text-3xl">
                                代わりにQRコードを<br>使用してください
                            </div>
                        </div>
                    </div>
                </div>
                <div>
                </div>
            </div>
        </div>
    </div>
    <script>

        const canvas = document.getElementById("canvas")
        const context = canvas.getContext('2d');
        const video = document.getElementById('webcam');
        const bc = new BroadcastChannel("p_hub_reception");
        const facebox = document.getElementById("face-box")
        const cropFaceCanvas = document.getElementById("crop-face-canvas")
        const faceCtx = cropFaceCanvas.getContext('2d');

        const { x: bx, y: by, width: bw } = document.getElementById("mode-button").getBoundingClientRect()
        const buttonS = bx
        const buttonE = bx + bw
        const buttonT = by
        const buttonB = by * 2.0

        const settings = JSON.parse(window.localStorage.getItem("settings")) || JSON.parse(window.localStorage.getItem("defaultSettings"))

        bc.onmessage = (event) => {
            const data = JSON.parse(event.data)
            if ("close" in data) {
                window.close()
            }
        }

        const setFPS = (fps) => {
            let lastTime = 0;
            const interval = 1000 / fps;

            return (currentTime) => {
                const elapsed = currentTime - lastTime;
                if (elapsed >= interval) {
                    lastTime = currentTime;
                    return true;
                }
                return false;
            }
        }



        class AsyncIterable {
            constructor(data, timeout) {
                this.data = data;
                this.timeout = timeout * 1000
            }

            async *[Symbol.asyncIterator]() {
                const timeout = this.timeout
                for (let item of this.data) {
                    await new Promise(resolve => setTimeout(resolve, timeout));
                    yield item;
                }
            }
        }

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        const faceDetection = new FaceDetection({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection@0.4/${file}`;
            }
        });

        const handFPS = setFPS(settings.handFPS)
        const faceFPS = setFPS(settings.faceFPS)

        document.addEventListener('alpine:init', () => {
            Alpine.store("reception", {
                faceRecognizationFailAlert: false,
                messageStatus: false,
                qrLoader: false,
                currentState: false,
                loader: false,
                failCount: 0,
                time: null,
                in: true,
                socket: null,
                verify: false,
                showMessage: false,
                message: "メッセージのロード",
                socketReady: false,
                messages: [
                    { content: "WOW! けっこいいですね。" },
                    { content: "俳優のように見えます。" },
                    { content: "うけつけにサインを残してください。" },
                    { content: "" }
                ],
                state() {
                    return {
                        FACE_DECTION: "FACE_DETECTION",
                        QR_DECETION: "QR_DECETION",
                    }
                },
                webcamStream: null,
                init() {

                    this.currentState = this.state().FACE_DECTION

                    setInterval(() => {
                        this.time = `${this.currentDate()} ${this.currentTime()}`
                    }, 1000)

                    faceDetection.setOptions({
                        model: 'short',
                        minDetectionConfidence: 0.8
                    });

                    hands.setOptions({
                        maxNumHands: 1,
                        modelComplexity: 1,
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });

                    const onHandResults = () => {
                        return (results) => {
                            const landmarks = results.multiHandLandmarks[0]
                            if (landmarks) {
                                const handX = this.mappedX(landmarks[12].x * video.videoWidth)
                                const handY = this.mappedY(landmarks[12].y * video.videoHeight)
                                if (handY >= buttonT && handY <= buttonB && handX >= buttonS && handX <= buttonE) {
                                    this.in = !this.in
                                    bc.postMessage(JSON.stringify({ in: this.in }))
                                }
                            }
                        }
                    }

                    const onFaceDetectionResult = () => {

                        let prevX;
                        let prevY;
                        let prevWidth;
                        let prevHeight;
                        let timeout
                        let resetTimeout;

                        return (result) => {

                            const detection = result.detections[0]


                            if (detection) {
                                let boundingBox = detection.boundingBox;
                                let width = (boundingBox.width * canvas.width) * 1.7
                                let height = (boundingBox.height * canvas.height) * 2.2;
                                let x = (boundingBox.xCenter * canvas.width) - (width / 2.0)
                                let y = (boundingBox.yCenter * canvas.height) - (height / 2.0);

                                if (Math.abs(x - prevX) < 15) {
                                    x = prevX
                                    y = prevY
                                    width = prevWidth
                                    height = prevHeight
                                    if (!timeout && !this.loader && this.currentState === this.state().FACE_DECTION && !this.messageStatus) {
                                        facebox.style.display = this.currentState !== this.state().FACE_DECTION ? "none" : "block"
                                        timeout = setTimeout(() => {
                                            timeout = null
                                            this.loader = true

                                            const faceWidth = boundingBox.width * 1.3 * video.videoWidth
                                            const faceHeight = boundingBox.width * 1.5 * video.videoHeight
                                            const faceX = (boundingBox.xCenter - ((boundingBox.width * 1.3) / 2)) * video.videoWidth;
                                            const faceY = (boundingBox.yCenter - ((boundingBox.height * 1.5) / 2)) * video.videoHeight;
                                            cropFaceCanvas.width = faceWidth
                                            cropFaceCanvas.height = faceHeight
                                            faceCtx.drawImage(video, faceX, faceY, faceWidth, faceHeight, 0, 0, faceWidth, faceHeight)
                                            this.recognizeFace(cropFaceCanvas.toDataURL())
                                        }, 300)
                                    }
                                } else {
                                    clearTimeout(timeout)
                                    timeout = null
                                }

                                facebox.style.right = `${x}px`;
                                facebox.style.top = `${y}px`;

                                facebox.style.width = `${width}px`
                                facebox.style.height = `${height}px`

                                prevX = x
                                prevY = y
                                prevWidth = width
                                prevHeight = height
                                clearTimeout(resetTimeout)
                                resetTimeout = null

                            } else {
                                facebox.style.display = "none"
                                if (!resetTimeout && !this.messageStatus) {
                                    resetTimeout = setTimeout(() => {
                                        resetTimeout = null
                                        this.reset()
                                    }, 2000)
                                }
                            }

                        }
                    }
                    this.connectSocket()
                    this.connectCamera()
                    faceDetection.onResults(onFaceDetectionResult());
                    hands.onResults(onHandResults());
                },
                reset() {
                    facebox.style.display = "none"
                    this.loader = false
                    this.failCount = 0
                    this.currentState = this.state().FACE_DECTION
                    this.verify = false
                },
                connectSocket() {
                    this.socket = new WebSocket(
                        'ws://' + window.location.host + '/ws/attendance/1/'
                    );

                    this.socket.onopen = () => {
                        this.reset()
                        this.socketReady = true
                    }

                    this.socket.onclose = (e) => {
                        console.log('Socket is closed. Reconnect will be attempted in 1 second.', e.reason);
                        this.socketReady = false
                        setTimeout(() => {
                            this.connectSocket();
                        }, 1000);
                    };

                    this.socket.onerror = (err) => {
                        console.error('Socket encountered error: ', err.message, 'Closing socket');
                        this.socket.close();
                    };

                    this.socket.onmessage = async (e) => {
                        const data = JSON.parse(e.data)

                        if (data.success) {
                            facebox.style.display = "none"
                            this.verify = true
                            this.messageStatus = true
                            const asyncMessages = new AsyncIterable(this.messages, settings.eventMessageDuration)
                            for await (let m of asyncMessages) {
                                if (m.content) {
                                    this.message = m.content
                                }
                            }
                            this.messageStatus = false
                            return
                        }

                        if (data.qr_code) {
                            Toastify({
                                text: settings.qrErrorMessage,
                                duration: settings.qrErrorAlertDuration * 1000,
                                gravity: "top",
                                position: "center",
                                style: {
                                    background: "red",
                                    fontSize: '36px',
                                    borderRadius: "5px"
                                },
                            }).showToast();
                        }


                        if (this.failCount === 2) {
                            facebox.style.display = "none"
                            this.faceRecognizationFailAlert = true
                            setTimeout(() => {
                                this.faceRecognizationFailAlert = false
                                this.currentState = this.state().QR_DECETION
                                this.loader = false
                            }, 3000);
                            return
                        }

                        this.failCount = this.failCount + 1

                        this.loader = false
                    }
                },
                connectCamera() {
                    navigator.mediaDevices.getUserMedia({ video: true, audio: false })
                        .then(stream => {
                            webcamStream = stream;
                            video.srcObject = stream;


                            video.addEventListener('loadedmetadata', () => {
                                width = canvas.width = window.innerWidth
                                height = canvas.height = window.innerHeight
                                const videoAspectRatio = video.videoWidth / video.videoHeight;
                                const canvasAspectRatio = canvas.width / canvas.height;

                                let drawWidth, drawHeight, drawX, drawY;

                                if (canvasAspectRatio > videoAspectRatio) {
                                    drawWidth = canvas.width;
                                    drawHeight = canvas.width / videoAspectRatio;
                                    drawX = 0;
                                    drawY = (canvas.height - drawHeight) / 2.0;
                                } else {
                                    drawWidth = canvas.height * videoAspectRatio;
                                    drawHeight = canvas.height;
                                    drawX = (canvas.width - drawWidth) / 2.0;
                                    drawY = 0;
                                }

                                const mapXRatio = drawWidth / video.videoWidth

                                const mapYRatio = drawHeight / video.videoHeight

                                this.mappedX = (x) => (drawX + x * mapXRatio);
                                this.mappedY = (y) => (drawY + y * mapYRatio) / 2.0

                                const drawCanvs = async (currentTime) => {

                                    context.clearRect(0, 0, canvas.width, canvas.height);
                                    context.save();
                                    context.drawImage(video, drawX, drawY, drawWidth, drawHeight);

                                    if (this.socketReady) {
                                        if (handFPS(currentTime)) {
                                            await hands.send({ image: video });
                                            const imageData = context.getImageData(0, 0, width, height)

                                            if (this.state === this.state().QR_DECETION) {
                                                const qr = jsQR(imageData.data, imageData.width, imageData.height)

                                                if (qr && !this.qrLoader) {
                                                    this.qrLoader = true
                                                    this.checkQR(canvas.toDataURL())
                                                }

                                                if (!qr) {
                                                    this.qrLoader = false
                                                }
                                            }
                                        }

                                        if (faceFPS(currentTime) && !this.qrLoader) {

                                            await faceDetection.send({ image: video });
                                        }
                                    }
                                    context.restore()
                                    requestAnimationFrame(drawCanvs)
                                }
                                requestAnimationFrame(drawCanvs)
                            });
                        })
                        .catch(error => {
                            console.error('Error accessing webcam:', error);
                        });
                },
                disconnectCamera() {
                    if (webcamStream) {
                        webcamStream.getTracks().forEach(track => track.stop());
                    }
                },
                recognizeFace(base64) {
                    this.socket.send(JSON.stringify({ "image_url": base64, "qr_code": false, event_id: 3, in: this.in }))

                },
                checkQR(base64) {
                    this.socket.send(JSON.stringify({ "image_url": base64, qr_code: true, event_id: 3, in: this.in }))
                },
                currentDate() {
                    const now = new Date();
                    const year = now.getFullYear();
                    const month = (now.getMonth() + 1).toString().padStart(2, '0'); // Month is zero-indexed
                    const day = now.getDate().toString().padStart(2, '0');

                    const dateString = `${year}-${month}-${day}`;
                    return dateString;
                },
                currentTime() {
                    const now = new Date();
                    const hours = now.getHours().toString().padStart(2, '0');
                    const minutes = now.getMinutes().toString().padStart(2, '0');
                    const seconds = now.getSeconds().toString().padStart(2, '0');

                    const timeString = `${hours}:${minutes}:${seconds}`;
                    return timeString
                }
            })
        })

    </script>
</body>

</html>