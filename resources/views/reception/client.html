{% load static %}
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="{% static 'css/app.css' %}?{% now 'U' %}">
    <script src="{% static 'js/mediapipe.js' %}"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script defer src="{% static 'js/app.js' %}?{% now 'U' %}"></script>
    <style>
        @keyframes example {
            0% {
                top: 5%;
            }

            50% {
                top: 95%;
            }

            100% {
                top: 0%;
            }
        }

        .x {
            animation: example 5s linear infinite;
            position: absolute;
            height: 2px;
            left: 3%;
            right: 3%;
            background-color: wheat;

        }
    </style>
</head>

<body>
    <div class="relative min-h-screen overflow-hidden">
        <video id="webcam" autoplay class="absolute-full object-cover scale-x-[-1]">
        </video>
        <canvas id="canvas" class="absolute-full  object-cover " style=" visibility: hidden;"></canvas>
        <div class="transition-[0.05s] z-[10]  absolute hidden" id="face-box">
            <div class="w-full h-full relative bg-opacity-40 p-5">
                <div class="border x"></div>
                <div class="size-20 absolute border-t-8 border-l-8 left-0  top-0 rounded-ss-[50%]"></div>
                <div class="size-20 absolute border-t-8 border-r-8 right-0 top-0 rounded-se-[50%] "></div>
                <div class="size-20 absolute border-l-8 border-b-8 left-0 bottom-0  rounded-bl-[50%]"></div>
                <div class="size-20 absolute border-r-8 border-b-8 right-0 bottom-0 rounded-br-[50%]"></div>
            </div>
        </div>
        <div class="bg-red-700 absolute-full z-[100] bg-opacity-50  flex justify-center items-center"
            x-transition.duration.500ms x-data x-cloak x-show="$store.reception.messageStatus">
            <div class="min-w-[500px] max-w-[1200px] text-white text-center">
                <h2 class="text-3xl underline">メッセージがあります</h2>
                <p class=" text-[4rem]  mt-10" x-text="$store.reception.message" x-transition:enter.duration.500ms
                    x-transition:leave.duration.400ms>
                </p>
            </div>
        </div>
        <div class="absolute top-5 left-5 right-5 bottom-5">
            <div class="w-full h-full flex flex-col justify-between p-5 relative ">
                <div class="absolute border border-white w-full h-full top-0 right-0 border-t-0 border-b-0"></div>
                <div class="top-0 left-0 right-0 absolute w-full flex justify-center ">
                    <div class="border border-white border-r-0 border-b-0 border-l-0 w-9"></div>
                    <div class="leading-[0px] px-3 text-white text-xl" x-data x-text="$store.reception.time">0000-00-00
                        00:00:00
                    </div>
                    <div class="border border-white border-r-0 border-b-0 border-l-0 flex-1"></div>
                </div>
                <div class="bottom-0 left-0 right-0 absolute w-full flex justify-center ">
                    <div class="border border-white border-r-0 border-b-0 border-l-0 w-[90%]"></div>
                    <div class="leading-[0px] px-3 text-white text-xl">P Hub</div>
                    <div class="border border-white border-r-0 border-b-0 border-l-0 flex-1"></div>
                </div>
                <div class="flex justify-between">
                    <button id="mode-button" style="visibility: hidden;"
                        class="bg-teal-500 z-50 px-[4%] py-[1%] text-[2rem]  text-center text-white rounded-[40px] border-[5px] border-white">
                        Mode : <span x-text="$store.reception.mode ? '入館': '退館'"></span>
                    </button>
                    <button x-data x-bind:class="$store.reception.mode ? 'bg-teal-500' : 'bg-yellow-300'"
                        class="bg-teal-500 z-50 px-[4%] py-[1%] text-[2rem]  text-center text-white rounded-[40px] border-[5px] border-white">
                        Mode : <span x-text="$store.reception.mode ? '入館': '退館'"></span>
                    </button>
                </div>
                <div class="flex justify-between items-start">
                    <div>
                        <div x-data x-show="$store.reception.verify" x-transition:enter.duration.500ms
                            class=" p-16 py-5 px-20 space-y-5 text-white rounded-[5px] bg-opacity-[0.4] bg-[#262323] flex flex-col justify-between items-center">
                            <div></div>
                            <div class="w-[100px] h-[100px] bg-lime-500 rounded-full flex justify-center items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class=" size-32 fill-white">
                                    <path fill-rule="evenodd"
                                        d="M19.916 4.626a.75.75 0 0 1 .208 1.04l-9 13.5a.75.75 0 0 1-1.154.114l-6-6a.75.75 0 0 1 1.06-1.06l5.353 5.353 8.493-12.74a.75.75 0 0 1 1.04-.207Z"
                                        clip-rule="evenodd" />
                                </svg>
                            </div>
                            <div class="text-2xl text-center">
                                <div>ワインヤンリン</div>
                                <div>1年○○○○療法</div>
                            </div>
                        </div>
                        <div x-data x-show="false"
                            class="bg-red-700 bg-opacity-45 max-w-[350px] text-white mt-5 p-2 rounded-lg">
                            問わ森自ハミテ散済はびで研供ソロ画感ツラ了遣
                        </div>
                    </div>
                    <div x-data x-transition:enter.duration.500ms x-transition:leave.duration.500ms
                        x-show="$store.reception.currentState === $store.reception.state().QR_DECETION"
                        class="p-7  text-white items-center bg-green-400 bg-opacity-45 rounded-lg">
                        <div class="flex justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                                stroke="currentColor" class="size-6/12 text-white">
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M3.75 4.875c0-.621.504-1.125 1.125-1.125h4.5c.621 0 1.125.504 1.125 1.125v4.5c0 .621-.504 1.125-1.125 1.125h-4.5A1.125 1.125 0 0 1 3.75 9.375v-4.5ZM3.75 14.625c0-.621.504-1.125 1.125-1.125h4.5c.621 0 1.125.504 1.125 1.125v4.5c0 .621-.504 1.125-1.125 1.125h-4.5a1.125 1.125 0 0 1-1.125-1.125v-4.5ZM13.5 4.875c0-.621.504-1.125 1.125-1.125h4.5c.621 0 1.125.504 1.125 1.125v4.5c0 .621-.504 1.125-1.125 1.125h-4.5A1.125 1.125 0 0 1 13.5 9.375v-4.5Z" />
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M6.75 6.75h.75v.75h-.75v-.75ZM6.75 16.5h.75v.75h-.75v-.75ZM16.5 6.75h.75v.75h-.75v-.75ZM13.5 13.5h.75v.75h-.75v-.75ZM13.5 19.5h.75v.75h-.75v-.75ZM19.5 13.5h.75v.75h-.75v-.75ZM19.5 19.5h.75v.75h-.75v-.75ZM16.5 16.5h.75v.75h-.75v-.75Z" />
                            </svg>
                        </div>
                        <div class="text-center font-semibold text-lg">
                            顔認識が失敗したため、<br>
                            代わりにQRコードを使用してください
                        </div>
                    </div>
                </div>
                <div>
                </div>
            </div>
        </div>
    </div>
    <script>

        const canvas = document.getElementById("canvas")
        const context = canvas.getContext('2d');
        const video = document.getElementById('webcam');
        const bc = new BroadcastChannel("p_hub_reception");
        const facebox = document.getElementById("face-box")

        const { x: bx, y: by, width: bw } = document.getElementById("mode-button").getBoundingClientRect()
        const buttonS = bx
        const buttonE = bx + bw
        const buttonT = by
        const buttonB = by * 2.0

        bc.onmessage = (event) => {
            const data = JSON.parse(event.data)
            if ("close" in data) {
                window.close()
            }
        }

        const setFPS = (fps) => {
            let lastTime = 0;
            const interval = 1000 / fps;

            return (currentTime) => {
                const elapsed = currentTime - lastTime;
                if (elapsed >= interval) {
                    lastTime = currentTime;
                    return true;
                }
                return false;
            }
        }



        class AsyncIterable {
            constructor(data) {
                this.data = data;
            }

            async *[Symbol.asyncIterator]() {
                for (let item of this.data) {
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    yield item;
                }
            }
        }

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        const faceDetection = new FaceDetection({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection@0.4/${file}`;
            }
        });

        const fps1 = setFPS(1)
        const fps30 = setFPS(20)


        document.addEventListener('alpine:init', () => {
            Alpine.store("reception", {
                messageStatus: false,
                qrLoader: false,
                currentState: false,
                loader: false,
                failCount: 0,
                time: null,
                mode: true,
                socket: null,
                verify: false,
                showMessage: false,
                message: "メッセージのロード",
                socketReady: false,
                messages: [
                    { content: "WOW! けっこいいですね。" },
                    { content: "俳優のように見えます。" },
                    { content: "うけつけにサインを残してください。" },
                    { content: "" }
                ],
                state() {
                    return {
                        FACE_DECTION: "FACE_DETECTION",
                        QR_DECETION: "QR_DECETION",
                    }
                },
                webcamStream: null,
                init() {

                    this.currentState = this.state().FACE_DECTION


                    setInterval(() => {
                        this.time = `${this.currentDate()} ${this.currentTime()}`
                    }, 1000)

                    faceDetection.setOptions({
                        model: 'short',
                        minDetectionConfidence: 0.8
                    });

                    hands.setOptions({
                        maxNumHands: 1,
                        modelComplexity: 1,
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });

                    const onHandResults = () => {
                        return (results) => {
                            const landmarks = results.multiHandLandmarks[0]
                            if (landmarks) {
                                const handX = this.mappedX(landmarks[12].x * video.videoWidth)
                                const handY = this.mappedY(landmarks[12].y * video.videoHeight)
                                console.log(handY)
                                if (handY >= buttonT && handY <= buttonB && handX >= buttonS && handX <= buttonE) {
                                    this.mode = !this.mode
                                    bc.postMessage(JSON.stringify({ mode: this.mode }))
                                }
                            }
                        }
                    }

                    const onFaceDetectionResult = () => {

                        let prevX;
                        let prevY;
                        let prevWidth;
                        let prevHeight;
                        let timeout
                        let resetTimeout;

                        return (result) => {

                            const detection = result.detections[0]

                            if (detection) {
                                let boundingBox = detection.boundingBox;
                                let width = Math.floor((boundingBox.width * canvas.clientWidth) * 1.5);
                                let height = Math.floor((boundingBox.height * canvas.clientHeight) * 1.8);
                                let x = Math.floor((boundingBox.xCenter * canvas.clientWidth) - width / 2)
                                let y = Math.floor((boundingBox.yCenter * canvas.clientHeight) - height / 2);

                                if (Math.abs(x - prevX) < 15) {
                                    x = prevX
                                    y = prevY
                                    width = prevWidth
                                    height = prevHeight
                                    if (!timeout && !this.loader && this.currentState === this.state().FACE_DECTION) {
                                        facebox.style.display = this.currentState !== this.state().FACE_DECTION ? "none" : "block"
                                        timeout = setTimeout(() => {
                                            timeout = null
                                            this.loader = true
                                 
                                            this.recognizeFace(canvas.toDataURL())
                                        }, 300)
                                    }
                                } else {
                                    clearTimeout(timeout)
                                    timeout = null
                                }

                                facebox.style.right = `${x}px`;
                                facebox.style.top = `${y}px`;

                                facebox.style.width = `${width}px`
                                facebox.style.height = `${height}px`

                                prevX = x
                                prevY = y
                                prevWidth = width
                                prevHeight = height
                                clearTimeout(resetTimeout)
                                resetTimeout = null

                            } else {
                                facebox.style.display = "none"
                                if (!resetTimeout) {
                                    resetTimeout = setTimeout(() => {
                                        resetTimeout = null
                                        this.reset()
                                    }, 2000)
                                }
                            }

                        }
                    }
                    this.connectSocket()
                    this.connectCamera()
                    faceDetection.onResults(onFaceDetectionResult());
                    hands.onResults(onHandResults());
                },
                reset() {
                    facebox.style.display = "none"
                    this.loader = false
                    this.failCount = 0
                    this.currentState = this.state().FACE_DECTION
                    this.verify = false
                },
                connectSocket() {
                    this.socket = new WebSocket(
                        'ws://' + window.location.host + '/ws/attendance/1/'
                    );

                    this.socket.onopen = () => {
                        this.socketReady = true
                    }

                    this.socket.onclose = (e) => {
                        console.log('Socket is closed. Reconnect will be attempted in 1 second.', e.reason);
                        setTimeout(() => {
                            this.connectSocket();
                        }, 1000);
                    };

                    this.socket.onerror = (err) => {
                        console.error('Socket encountered error: ', err.message, 'Closing socket');
                        this.socket.close();
                    };

                    this.socket.onmessage = async (e) => {
                        const data = JSON.parse(e.data)

                        if (data.success) {
                            facebox.style.display = "none"
                            this.verify = true
                            this.messageStatus = true
                            const asyncMessages = new AsyncIterable(this.messages)
                            for await (let m of asyncMessages) {
                                if(m.content) {
                                    this.message = m.content
                                }
                            }
                            this.messageStatus = false
                            return
                        }

                        if (data.qr_code) {
                            Toastify({
                                text: "未承認のQRコードです。",
                                duration: 3000,
                                gravity: "top",
                                position: "center",
                                style: {
                                    background: "red",
                                    fontSize: '36px',
                                    borderRadius: "5px"
                                },
                            }).showToast();
                        }

                        this.loader = false

                        if (this.failCount === 2) {
                            this.currentState = this.state().QR_DECETION
                            facebox.style.display = "none"
                            return
                        }

                        this.failCount = this.failCount + 1
                    }
                },
                connectCamera() {
                    navigator.mediaDevices.getUserMedia({ video: true, audio: false })
                        .then(stream => {
                            webcamStream = stream;
                            video.srcObject = stream;


                            video.addEventListener('loadedmetadata', () => {
                                width = canvas.width = window.innerWidth
                                height = canvas.height = window.innerHeight
                                const videoAspectRatio = video.videoWidth / video.videoHeight;
                                const canvasAspectRatio = canvas.width / canvas.height;

                                let drawWidth, drawHeight, drawX, drawY;

                                if (canvasAspectRatio > videoAspectRatio) {
                                    drawWidth = canvas.width;
                                    drawHeight = canvas.width / videoAspectRatio;
                                    drawX = 0;
                                    drawY = (canvas.height - drawHeight) / 2.0;
                                } else {
                                    drawWidth = canvas.height * videoAspectRatio;
                                    drawHeight = canvas.height;
                                    drawX = (canvas.width - drawWidth) / 2.0;
                                    drawY = 0;
                                }

                                const mapXRatio = drawWidth / video.videoWidth

                                const mapYRatio = drawHeight / video.videoHeight

                                this.mappedX = (x) => (drawX + x * mapXRatio);
                                this.mappedY = (y) => (drawY + y * mapYRatio) / 2.0

                                const drawCanvs = async (currentTime) => {

                                    context.clearRect(0, 0, canvas.width, canvas.height);
                                    context.save();
                                    context.drawImage(video, drawX, drawY, drawWidth, drawHeight);

                                    if (this.socketReady) {
                                        if (fps1(currentTime)) {
                                            await hands.send({ image: video });
                                            const imageData = context.getImageData(0, 0, width, height)

                                            if (this.state === this.state().QR_DECETION) {
                                                const qr = jsQR(imageData.data, imageData.width, imageData.height)

                                                if (qr && !this.qrLoader) {
                                                    this.qrLoader = true
                                                    this.checkQR(canvas.toDataURL())
                                                }

                                                if (!qr) {
                                                    this.qrLoader = false
                                                }
                                            }
                                        }

                                        if (fps30(currentTime) && !this.qrLoader) {
                                            await faceDetection.send({ image: video });
                                        }
                                    }
                                    context.restore()
                                    requestAnimationFrame(drawCanvs)
                                }
                                requestAnimationFrame(drawCanvs)
                            });
                        })
                        .catch(error => {
                            console.error('Error accessing webcam:', error);
                        });
                },
                disconnectCamera() {
                    if (webcamStream) {
                        webcamStream.getTracks().forEach(track => track.stop());
                    }
                },
                recognizeFace(base64) {
                    this.socket.send(JSON.stringify({ "image_url": base64, "qr_code": false }))

                },
                checkQR(base64) {
                    this.socket.send(JSON.stringify({ "image_url": base64, qr_code: true }))
                },
                currentDate() {
                    const now = new Date();
                    const year = now.getFullYear();
                    const month = (now.getMonth() + 1).toString().padStart(2, '0'); // Month is zero-indexed
                    const day = now.getDate().toString().padStart(2, '0');

                    const dateString = `${year}-${month}-${day}`;
                    return dateString;
                },
                currentTime() {
                    const now = new Date();
                    const hours = now.getHours().toString().padStart(2, '0');
                    const minutes = now.getMinutes().toString().padStart(2, '0');
                    const seconds = now.getSeconds().toString().padStart(2, '0');

                    const timeString = `${hours}:${minutes}:${seconds}`;
                    return timeString
                }
            })
        })

    </script>
</body>

</html>