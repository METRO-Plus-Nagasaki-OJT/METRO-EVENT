{% load static %}
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="{% static 'css/app.css' %}?{% now 'U' %}">
    <script src="{% static 'js/mediapipe.js' %}"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script defer src="{% static 'js/app.js' %}?{% now 'U' %}"></script>
    <style>
        @keyframes example {
            0% {
                top: 5%;
            }

            50% {
                top: 95%;
            }

            100% {
                top: 0%;
            }
        }

        .x {
            animation: example 5s linear infinite;
            position: absolute;
            height: 2px;
            left: 3%;
            right: 3%;
            background-color: wheat;

        }
    </style>
</head>

<body>
    <div class="relative min-h-screen overflow-hidden">
        <video id="webcam" autoplay hidden class="absolute-full object-cover scale-x-[-1]">
        </video>
        <canvas id="canvas" class="absolute-full object-cover"></canvas>
        <div class="transition-[0.05s] z-[10]  absolute hidden" id="face-box">
            <div class="w-full h-full relative bg-opacity-40 p-5">
                <div class="border x"></div>
                <div class="size-20 absolute border-t-8 border-l-8 left-0  top-0 rounded-ss-[50%]"></div>
                <div class="size-20 absolute border-t-8 border-r-8 right-0 top-0 rounded-se-[50%] "></div>
                <div class="size-20 absolute border-l-8 border-b-8 left-0 bottom-0  rounded-bl-[50%]"></div>
                <div class="size-20 absolute border-r-8 border-b-8 right-0 bottom-0 rounded-br-[50%]"></div>
            </div>
        </div>
        <div class="bg-red-700 absolute-full bg-opacity-50  flex justify-center items-center"
            x-transition.duration.500ms x-data x-cloak x-show="$store.reception.showMessage">
            <div class="min-w-[500px] max-w-[1000px] text-white text-center">
                <h2 class="text-3xl underline">メッセージがあります</h2>
                <p class="text-4xl  mt-10">
                    問わ森自ハミテ散済はびで研供ソロ画感ツラ了遣ふ掲来もに本8令アヲ搭芸けぐき国加もぶみ交万みび下禁分普かうい。刻資るけイゆ脱多ちづ政国ノ全対チワ護更堂キ学月だ応一著づ解側ノシスユ示他のだ術有のるうぞ域銀ぜもゆ季也野打稲み。東ウサソヲ南1京価ニメ覧5分鷹よ汁気4仙ヱ詳被ナヌミ国撮こもお岐問んぽづ勝減読うし意中ユシツヱ手
                </p>
            </div>
        </div>
        <div class="absolute top-5 left-5 right-5 bottom-5">
            <div class="w-full h-full flex flex-col justify-between p-5 relative ">
                <div class="absolute border border-white w-full h-full top-0 right-0 border-t-0 border-b-0"></div>
                <div class="top-0 left-0 right-0 absolute w-full flex justify-center ">
                    <div class="border border-white border-r-0 border-b-0 border-l-0 w-9"></div>
                    <div class="leading-[0px] px-3 text-white text-xl" x-data x-text="$store.reception.time">0000-00-00
                        00:00:00
                    </div>
                    <div class="border border-white border-r-0 border-b-0 border-l-0 flex-1"></div>
                </div>
                <div class="bottom-0 left-0 right-0 absolute w-full flex justify-center ">
                    <div class="border border-white border-r-0 border-b-0 border-l-0 w-[90%]"></div>
                    <div class="leading-[0px] px-3 text-white text-xl">P Hub</div>
                    <div class="border border-white border-r-0 border-b-0 border-l-0 flex-1"></div>
                </div>
                <div class="text-right">
                    <button id="mode-button" x-data
                        x-bind:class="$store.reception.mode ? 'bg-teal-500' : 'bg-yellow-300'"
                        class="bg-teal-500 z-50 px-[4%] py-[1%] text-[2rem]  text-center text-white rounded-[40px] border-[5px] border-white">
                        Mode : <span x-text="$store.reception.mode ? '入館': '退館'"></span>
                    </button>
                </div>
                <div class="flex justify-between items-start">
                    <div>
                        <div x-data x-show="$store.reception.verify" x-transition:enter.duration.500ms
                            class=" p-16 py-5 px-20 space-y-5 text-white rounded-[5px] bg-opacity-[0.4] bg-[#262323] flex flex-col justify-between items-center">
                            <div></div>
                            <div class="w-[100px] h-[100px] bg-lime-500 rounded-full flex justify-center items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class=" size-32 fill-white">
                                    <path fill-rule="evenodd"
                                        d="M19.916 4.626a.75.75 0 0 1 .208 1.04l-9 13.5a.75.75 0 0 1-1.154.114l-6-6a.75.75 0 0 1 1.06-1.06l5.353 5.353 8.493-12.74a.75.75 0 0 1 1.04-.207Z"
                                        clip-rule="evenodd" />
                                </svg>
                            </div>
                            <div class="text-2xl text-center">
                                <div>山田様</div>
                                <div>1年○○○○療法</div>
                            </div>
                        </div>
                        <div x-data x-show="false"
                            class="bg-red-700 bg-opacity-45 max-w-[350px] text-white mt-5 p-2 rounded-lg">
                            問わ森自ハミテ散済はびで研供ソロ画感ツラ了遣
                        </div>
                    </div>
                    <div x-data x-transition:enter.duration.500ms x-show="$store.reception.showQrAlert"
                        class="p-5 border text-white items-center">
                        <div class="flex justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                                stroke="currentColor" class="size-6/12 text-white">
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M3.75 4.875c0-.621.504-1.125 1.125-1.125h4.5c.621 0 1.125.504 1.125 1.125v4.5c0 .621-.504 1.125-1.125 1.125h-4.5A1.125 1.125 0 0 1 3.75 9.375v-4.5ZM3.75 14.625c0-.621.504-1.125 1.125-1.125h4.5c.621 0 1.125.504 1.125 1.125v4.5c0 .621-.504 1.125-1.125 1.125h-4.5a1.125 1.125 0 0 1-1.125-1.125v-4.5ZM13.5 4.875c0-.621.504-1.125 1.125-1.125h4.5c.621 0 1.125.504 1.125 1.125v4.5c0 .621-.504 1.125-1.125 1.125h-4.5A1.125 1.125 0 0 1 13.5 9.375v-4.5Z" />
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M6.75 6.75h.75v.75h-.75v-.75ZM6.75 16.5h.75v.75h-.75v-.75ZM16.5 6.75h.75v.75h-.75v-.75ZM13.5 13.5h.75v.75h-.75v-.75ZM13.5 19.5h.75v.75h-.75v-.75ZM19.5 13.5h.75v.75h-.75v-.75ZM19.5 19.5h.75v.75h-.75v-.75ZM16.5 16.5h.75v.75h-.75v-.75Z" />
                            </svg>
                        </div>
                        <div class="text-center">
                            The face detection fail use the qr code
                        </div>
                    </div>
                </div>
                <div>
                </div>
            </div>
        </div>
    </div>
    <script>

        const canvas = document.getElementById("canvas")
        const context = canvas.getContext('2d');
        const video = document.getElementById('webcam');
        const bc = new BroadcastChannel("p_hub_reception");
        const facebox = document.getElementById("face-box")

        bc.onmessage = (event) => {
            const data = JSON.parse(event.data)
            if ("close" in data) {
                window.close()
            }
        }

        const setFPS = (fps) => {
            let lastTime = 0;
            const interval = 1000 / fps;

            return (currentTime) => {
                const elapsed = currentTime - lastTime;
                if (elapsed >= interval) {
                    lastTime = currentTime;
                    return true;
                }
                return false;
            }
        }



        class AsyncIterable {
            constructor(data) {
                this.data = data;
            }

            async *[Symbol.asyncIterator]() {
                for (let item of this.data) {
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }
        }

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        const faceDetection = new FaceDetection({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection@0.4/${file}`;
            }
        });

        const FPS1 = setFPS(1)
        const FPS30 = setFPS(30)

        document.addEventListener('alpine:init', () => {
            Alpine.store("reception", {
                showQrAlert: false,
                faceRegonization: true,
                loader: false,
                failCount: 0,
                time: null,
                mode: true,
                socket: null,
                verify: false,
                showMessage: false,
                message: null,
                socketReady: false,
                messages: [
                    { content: "問わ森自ハミテ散済はびで研供ソロ画感ツラ了遣ふ掲来もに本8令アヲ搭芸けぐき国加もぶみ交万みび下禁分普かうい。刻資るけイゆ脱多ちづ政国ノ全対チワ護更堂キ学月だ応一著づ解側ノシスユ示他のだ術有のるうぞ域銀ぜもゆ季也野打稲み。東ウサソヲ南1京価ニメ覧5分鷹よ汁気4仙ヱ詳被ナヌミ国撮こもお岐問んぽづ勝減読うし意中ユシツヱ手" },
                    { content: "権んりをき大軽ど界細ひ外球ワイセラ女新カメソ社74着テ立遊ぴなむ月治ナカヱヒ展掲ぱゅ務銃うどよク陳火んリ利致こクべ英将ぜお本痛傾ーリぶ。購67状締拳5近ぶょ排掲ケ急掲ムコ上7健ロ台検ぞきス団著前方ネ報焼のだとび謝意チオ想安メウ融写壮憶ッ。力ずざえび略省年か制年クキソエ終工決ワキケ学隆じだふ期7混ぞリぐゆ所位コネヱ性体断どかぽ都後ネケツミ都最額拠セキサ端心とぼゆに" },
                    { content: "同とぽゃ早50持スし碁7策ナモヒ禁事にう買財ふっ袋止ドざぱご立67議忘チアム択原にンつへ年単構満ねとイッ。著39増ホユスリ仙無フおい誌速ワミノ長層ヒ朝勧ヨ社問にー交試サオメス業終ウヲシヒ大喫なゅ防生ぽふッレ較5速覧皇仲儀ざぎ。明ニカ果人ヲヘ進別すこげ世横はい言袋ケ医選ほ出維モヤセヒ制毎ヱタ最供そにおい央撲フ疑会キマ禁採ナヨクタ滋防大トせ教練クもず文更投温うむ要旨傑摯晋こ。" }
                ],
                webcamStream: null,
                init() {
                    const reception = this
                    this.message = this.messages[0].content

                    setInterval(() => {
                        this.time = `${this.currentDate()} ${this.currentTime()}`
                    }, 1000)

                    faceDetection.setOptions({
                        model: 'short',
                        minDetectionConfidence: 0.8
                    });

                    hands.setOptions({
                        maxNumHands: 1,
                        modelComplexity: 1,
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });

                    const onHandResults = () => {
                        return (results) => {
                            const landmarks = results.multiHandLandmarks[0]


                            landmarks?.forEach(function (l) {
                                const x = l.x
                                const y = l.y

                                console.log(x * canvas.width)
                                if (x > 0 && x.toFixed(1) < 0.3 && y > 0 && y.toFixed(1) < 0.3) {
                                    this.mode = !this.mode
                                    bc.postMessage(JSON.stringify({ mode: this.mode }))
                                }
                            }.bind(this))
                        }
                    }

                    const onFaceDetectionResult = () => {

                        let prevX;
                        let prevY;
                        let prevWidth;
                        let prevHeight;
                        let timeout

                        return (result) => {

                            const detection = result.detections[0]

                            if (detection) {
                                let boundingBox = detection.boundingBox;
                                let width = Math.floor((boundingBox.width * canvas.width) * 5);
                                let height = Math.floor((boundingBox.height * canvas.height) * 5);
                                let x = Math.floor((boundingBox.xCenter * canvas.clientWidth) - width / 2)
                                let y = Math.floor((boundingBox.yCenter * canvas.clientHeight) - height / 2) * 0.8;

                                facebox.style.display = !this.faceRegonization ? "none" : "block"

                                if (Math.abs(x - prevX) < 15) {
                                    x = prevX
                                    y = prevY
                                    width = prevWidth
                                    height = prevHeight
                                    if (!timeout) {
                                        timeout = setTimeout(() => {
                                            timeout = undefined
                                            if (this.faceRegonization) {
                                                this.recognizeFace()
                                            }
                                        }, 300)
                                    }
                                } else {
                                    clearTimeout(timeout)
                                    timeout = undefined
                                }

                                facebox.style.right = `${x}px`;
                                facebox.style.top = `${y}px`;

                                facebox.style.width = `${width}px`
                                facebox.style.height = `${height}px`

                                prevX = x
                                prevY = y
                                prevWidth = width
                                prevHeight = height
                            } else {
                                facebox.style.display = "none"
                                this.loader = false
                                this.failCount = 0
                                this.faceRegonization = true
                                this.verify = false
                                this.showQrAlert = false
                            }

                        }
                    }
                    this.connectSocket()
                    this.connectCamera()
                    faceDetection.onResults(onFaceDetectionResult());
                    hands.onResults(onHandResults());
                },
                connectSocket() {
                    const reception = this

                    this.socket = new WebSocket(
                        'ws://' + window.location.host + '/ws/attendance/1/'
                    );

                    this.socket.onopen = () => {
                        reception.socketReady = true
                    }

                    this.socket.onclose = (e) => {
                        console.log('Socket is closed. Reconnect will be attempted in 1 second.', e.reason);
                        setTimeout(() => {
                            reception.socket.connect();
                        }, 1000);
                    };

                    this.socket.onerror = (err) => {
                        console.error('Socket encountered error: ', err.message, 'Closing socket');
                        reception.socket.close();
                    };

                    this.socket.onmessage = (e) => {
                        const data = JSON.parse(e.data)
                        if (data.success) {
                            reception.verify = true
                            reception.failCount = 0
                        } else if (reception.failCount <= 2) {
                            reception.loader = false
                            if (reception.failCount === 2) {
                                reception.faceRegonization = false
                                facebox.style.display = "none"
                                reception.showQrAlert = true
                            } else {
                                reception.failCount = reception.failCount + 1
                            }
                        }
                    }
                },
                connectCamera() {
                    navigator.mediaDevices.getUserMedia({ video: true, audio: false })
                        .then(stream => {
                            webcamStream = stream;
                            video.srcObject = stream;

                            const reception = this

                            const drawCanvs = async (currentTime) => {
                                width = canvas.width = video.videoWidth;
                                height = canvas.height = video.videoHeight;
                                context.save();
                                context.scale(-1, 1);
                                context.drawImage(video, -width, 0, width, height);

                                const rectX = -canvas.width; // Adjusted x-coordinate to place the rectangle on the right
                                const rectY = 120;
                                const rectWidth = 200;
                                const rectHeight = 100;

                                context.fillStyle = 'blue'; // Fill color
                                context.fillRect(rectX, rectY, rectWidth, rectHeight); // (x, y, width, height)

                                // Optionally, draw a border
                                context.strokeStyle = 'red'; // Border color
                                context.lineWidth = 2; // Border width
                                context.strokeRect(rectX, rectY, rectWidth, rectHeight); 

                                if (FPS1(currentTime)) {
                                    await hands.send({ image: video });
                                    if (width && !reception.loader && !reception.faceRegonization) {
                                        const imageData = context.getImageData(0, 0, width, height)
                                        const code = jsQR(imageData.data, imageData.width, imageData.height)
                                        if (code) {
                                            reception.loader = true
                                            reception.checkQR()
                                        }
                                    }
                                }

                                if (FPS30(currentTime)) {
                                    await faceDetection.send({ image: video });
                                }

                                context.restore()
                                requestAnimationFrame(drawCanvs)
                            }
                            requestAnimationFrame(drawCanvs)
                        })
                        .catch(error => {
                            console.error('Error accessing webcam:', error);
                        });
                },
                disconnectCamera() {
                    if (webcamStream) {
                        webcamStream.getTracks().forEach(track => track.stop());
                    }
                },
                recognizeFace() {
                    if (!this.loader && this.socketReady) {
                        this.loader = true
                        const base64 = canvas.toDataURL();
                        this.socket.send(JSON.stringify({ "image_url": base64, "qr_code": false }))
                    }

                },
                checkQR() {
                    const base64 = canvas.toDataURL();
                    this.socket.send(JSON.stringify({ "image_url": base64, qr_code: true }))
                },
                currentDate() {
                    const now = new Date();
                    const year = now.getFullYear();
                    const month = (now.getMonth() + 1).toString().padStart(2, '0'); // Month is zero-indexed
                    const day = now.getDate().toString().padStart(2, '0');

                    const dateString = `${year}-${month}-${day}`;
                    return dateString;
                },
                currentTime() {
                    const now = new Date();
                    const hours = now.getHours().toString().padStart(2, '0');
                    const minutes = now.getMinutes().toString().padStart(2, '0');
                    const seconds = now.getSeconds().toString().padStart(2, '0');

                    const timeString = `${hours}:${minutes}:${seconds}`;
                    return timeString
                }
            })
        })

    </script>
</body>

</html>